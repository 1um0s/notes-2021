---
title: "Storage: Privacy and Policies"
author: Abitha Thankaraj  <at4524@nyu.edu>
---

# Introduction

# Motivation

## GDPR

## Introduction
The General Data Protection Regulation (GDPR) provides new rights and protections to European people concerning their personal data. 
The paper analyses GDPR from a systems perspective, translating its legal articles into a set of capabilities and characteristics that compliant systems must support.

While databases are generally optimised for performance, introduction of GDPR constraints affects performance.
aim to understand and evaluate GDPR compliance of existing database systems.
## Motivation
What is the problem that the papers are looking at, and why are they looking at
this? 
This is a bit harder for the two introduction lectures, since they try to
overview the area.

- How do non-technical requirements/ policies affect the design of a database system?
- Privacy and security policies and Enforcing them


### Approaches
Talk a bit about the approaches the papers discussed, and what you found from
your research.


Design and Implementation of GDPR bench


### Trade-Offs
Compare the approaches, discuss when they might be appropriate. For example,
some techniques might only make sense with a lot of data, or in the absence of
multiple tenants, etc.


- Compliance may result in high performance overheads : While it is straight forward to retrofit Redis and PostgreSQL into GDPR compliance, the resulting performance degradation of 2-5x raises fundamental questions of compliance-efficiency tradeoffs
- Compliant systems experience challenges at scale : Naive efforts at achieving GDPR compliance results in poor scalability. Increasing the volume of personal data, even by modest amounts, makes it challenging to respond to customer's GDPR rights in a timely manner.
- Compliance is easier & effective in RDBMS than NoSQL : Redis needed two changes at the internal design level as opposed to only configuration changes and external scripting for PostgreSQL. Even from a performance viewpoint, the drop is steeper in Redis than PostgreSQL
- GDPR is strict in its principles yet flexible in practice : GDPR is intentionally vague in its technical specifications. Treating compliance as a spectrum instead of a fixed target, allows database engineers and administrators to explore the tradeoff between strict compliance vs. high performance.
    


### Open Questions and Future Work
How are the current trends affecting the area, what are some open questions
about the problem, etc.

* Practical implementation of gdpr : To offset performance degradtion, is it viable to use lambda architecture.
ie- slow and fast layer
* What is the incentive for a company to actually implement the strictest version of GDPR?


# Obladi
### Motivation
Today, several applications are moving to the cloud either for better fault tolerance or for better scalability. For
 applications that store sensitive information, using cloud
 storage comes with the risk of sharing data with an untrusted third party. As evidenced previously, cloud services
  can be
  a target of hacking, can be subpoenaed by government agencies etc. 
  
  While we can use encryption to hide the contents of the data being stored, the adversary may still be able to
   guess the nature of the data based on the access patterns, namely,
   - what data is being accessed
   - when the data is being accessed
   - how the data is being accessed (wheher it is read or write)
This paper aims to guarantee **obliviousness** by hiding these access patterns.

This paper presents methods to obliviously and efficiently implement serializable ACID transactions on top of
 untrusted cloud storage
;p
### Terms
* **ORAM**: Oblivious RAM (ORAM) allows a client to access her data on a remote server while hiding the access pattern
 (which locations she is accessing) from the server.  Beyond its immediate utility in allowing private computation over a client’s outsourced data, ORAM also allows mutually distrustful parties to run secure-computations over their joint data with sublinear on-line complexity.
* **Obliviousness**: gives no information about the sequence or pattern of the operations that have been applied except
 for the final result of the operations.
* ACID Properties
    * **Atomicity**: All changes to data are performed as if they are a single operation. That is, all the changes are
 performed, or none of them are.
For example, in an application that transfers funds from one account to another, the atomicity property ensures that, if a debit is made successfully from one account, the corresponding credit is made to the other account.
    * **Consistency**: Data is in a consistent state when a transaction starts and when it ends.
For example, in an application that transfers funds from one account to another, the consistency property ensures that the total value of funds in both the accounts is the same at the start and end of each transaction.
    * **Isolation**: The intermediate state of a transaction is invisible to other transactions. As a result, transactions
 that run concurrently appear to be serialized.
For example, in an application that transfers funds from one account to another, the isolation property ensures that another transaction sees the transferred funds in one account or the other, but not in both, nor in neither.
    * **Durability**: After a transaction successfully completes, changes to data persist and are not undone, even in the
 event of a system failure. For example, in an application that transfers funds from one account to another, the
  durability property ensures that the changes made to each account will not be reversed.


### Approaches

#### Security guarantees
The adversary should learn no information about
1. the data accessed by ongoing transactions
2. the type of operations in ongoing transactions
3. the size of ongoing transactions
4. the outcome of ongoing transactions
<--TODO : Insert Image here>

ie. The blue reads should be no different from the red write sequence to an adversary.

#### Architecture details

- **Threat model**: Obladi adopts the _trusted proxy model_, ie. there is a centralised trusted proxy through with
 the clients can communicate o the external cloud
<--TODO : Insert Image here-->

- **Failure model**: Obladi assumes that the clients and the proxy can fail. But, the cloud storage is reliable. 
 
<--TODO : Insert Image here-->

- **Workload independence** The request pattern sent to the untrusted cloud is independent of ongoing transactions.
- This guarantees that the adversary never learns information about the workload by simply observing the reads and
 writes to the cloud.
 
- Obladi builds on ORAM - [Goldreich1996](TODO). ORAM hides access patterns for read and write operations by making requests to untrusted storage independent of workload
- Generate physical read/write requests from logical operations. Send requests to (encrypted) dummy data to hide what
 is being requested

Challenges of Transactional ORAM
- How do we guarantee isolation and durability on top of ORAM when there is no concurrency control? 
- How do we guarantee consistency and durability? Durability mandates specific ordering of write for consistency. ORAM
 mandates different but equally specific ordering of writes (write back ordering) for security.
- How do we guarantee good performance when most ORAM offers only limited concurrency?  

Obladi's solution - **delayed visibility** 
1. ACID guarantees apply only when transactions commit
2. commit operations can be delayed

Epochs

Consistency and durability
- Obladi uses delayed visibility to partition transaction into fixed-sized epochs
- Delays commit notifications until the epoch ends
- Enforce durability and consistency at epoch boundaries only

Performance gains from delayed visibility
- Within an epoch, Obladi executes transactions at the trusted proxy, buffering writes until epoch ends. This reduces
 number of requests sent to ORAM. ie. Only the last version of every key within an epoch is written
-  Implement multi-versioned concurrency control algorithm on top of single-versioned ORAM

- Delayed visibility should not increase contention.
- Should allow transactions in the same epoch to see each other’s effects.
- Obladi chooses a concurrency control that optimistically exposes uncommitted writes to ongoing transactions.

- The fixed structure of epochs helps guarantee workload independence.
- Epochs are padded if needed to ensure that they all have the same size.
- ORAM observes the same sequence of reads followed by the buffered writes.

Guaranteeing good performance
- Batch the requests sent to ORAM
- But ORAM's are mostly sequential, and the class of applications being studied have highly concurrent requests.
- Solution: Parallelize ORAM. 
    - For _correctness_: parallelization should be _linearizable_
    - For _security_: parallelization should be _workload independent_

- To ensure linearizability, execute operations that do not have data dependencies in parallel

Side channel vulnerability 
- But, data dependencies can violate independence. Wait for data dependencies to be satisfied introduces _timing
 channels_ since dependencies only exist between real objects, not dummies. Delaying reads for real objects causes delay, dummy objects don’t
- Must wait for all potential data dependencies Can exist between
 any pairs of reads and writes
 
Solution
- Delayed visibility allows ORAM to be consistent at epoch boundaries only Writes can be safely delayed to epoch end
- Separate ORAM execution into a read phase and a write phase
    - Read Phase: reads all necessary blocks 
    - Write Phase: writes all necessary blocks
    - Executing each phase in turn obscures data dependencies 
    - Still allows high concurrency

Guaranteeing durability
- Must ensure recovery to a consistent state. ie- No partially executed transactions are included
- Traditionally achieved through redo/undo logging
    - For consistency: pretend partial transactions never happened 
    - For security: cannot “undo” what the adversary observed -> may lead to sequences that violate workload
     independence
Durability and recovery logic details

<--!TODO-->
### Trade-Offs


The following workloads used to evaluate the performance of Obladi
<--!TODO Add description of workloads-->
- TPC-C
- SMallbank
- FreeHealth


- Obladi is slow, but not too slow
- Between 5x and 9x lower throughput for contention- bottlenecked TPC-C and FreeHealth.
- 12x lower throughput for resource- bottlenecked SmallBank
<--TODO : Insert Image here-->

- Batching significantly increases latency. But latency remains within 100s of ms
- Up to 70x on TPC-C
- Better on other applications because of smaller write batches
<--TODO : Insert Image here-->


- Performance is sensitive to good tuning of epoch size
    - If too low, transactions cannot finish
    - If too high, idle time
<--TODO : Insert Image here-->
- Note: Smallbank shows a sharp drop in throughput after 15ms. The Smallbank workload has similar transactions with most
 having similar transaction times. Either all the transactions can commit or none can. Whereas in the TPC-C worload
 , the drop in throughput is less pronounced, ie. there are shorter transactions that can commit first 
- Such distinct footprints may reveal the type of application.
- Obladi does not attempt to hide the type of application, only hides the nature of the currently executing
 transaction.  

### Open Questions and Future Work
* How would Obladi scale wih multiple proxies?


## Differential privacy
### Terms:
* **Adjacent databases**:
* **Sensitivity** : My presence on absence changes the
* Better privacy or smaller epsilon means more 


### Approaches
* Randomization
* Laplacian distribution

### Trade-Offs

### Open Questions and Future Work

